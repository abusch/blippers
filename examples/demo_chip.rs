//! Simple NES-like sound chip emulator that plays back file of logged writes
use std::{error::Error, fs::File, io::BufWriter};

use blippers::BlipBuf;
use hound::{SampleFormat, WavSpec, WavWriter};

// 44.1 kHz sample rate
const SAMPLE_RATE: f64 = 44100.0;
// 1.78 MHz clock rate
const CLOCK_RATE: f64 = 1789772.727;

fn main() -> Result<(), Box<dyn Error>> {
    let mut gen = ChipGenerator::new()?;

    // Open log of writes to sound hardware
    let f = std::fs::read_to_string("examples/demo_log.txt")?;
    let mut lines = f.lines();

    while gen.sample_count < 120 * SAMPLE_RATE as u32 {
        if let Some(line) = lines.next() {
            // in an emulator these writes would be generated by the emulated CPU
            let splits = line.split(' ').collect::<Vec<_>>();
            let time = splits[0].parse::<u64>()?;
            let chan = splits[1].parse::<usize>()?;
            let addr = splits[2].parse::<usize>()?;
            let data = splits[3].parse::<i32>()?;

            if chan < 4 {
                gen.write_chan(time, chan, addr, data);
            } else {
                gen.end_frame(time);
            }
        } else {
            break;
        }
    }

    Ok(())
}

const MASTER_VOL: i32 = 65536 / 15;
const PERIOD: usize = 0;
const VOLUME: usize = 1;
const TIMBRE: usize = 2;
struct ChipGenerator {
    chans: [Chan; 4],
    sample_count: u32,
    blip: BlipBuf,
    wav: WavWriter<BufWriter<File>>,
}

impl ChipGenerator {
    fn new() -> Result<Self, Box<dyn Error>> {
        let mut blip = BlipBuf::new((SAMPLE_RATE / 10.0) as usize);
        blip.set_rates(CLOCK_RATE, SAMPLE_RATE);

        let wav = wave_writer()?;

        Ok(Self {
            blip,
            chans: [
                Chan::new(ChanType::Square, MASTER_VOL * 26 / 100),
                Chan::new(ChanType::Square, MASTER_VOL * 26 / 100),
                Chan::new(ChanType::Triangle, MASTER_VOL * 30 / 100),
                Chan::new(ChanType::Noise, MASTER_VOL * 18 / 100),
            ],
            sample_count: 0,
            wav,
        })
    }

    /// Runs channel to specified time, then writes data to channel's register
    fn write_chan(&mut self, time: u64, chan: usize, addr: usize, data: i32) {
        self.run_chan(chan, time);
        self.chans[chan].regs[addr] = data;
    }

    /// Ends time frame and flushes samples
    fn end_frame(&mut self, end_time: u64) {
        for i in 0..4 {
            self.run_chan(i, end_time);
            self.chans[i].time -= end_time;
        }
        self.blip.end_frame(end_time);

        while self.blip.samples_avail() > 0 {
            const TEMP_SIZE: usize = 1024;
            let mut temp = [0i16; TEMP_SIZE];

            // count is number of samples actuall read (in case there were fewer than temp_size
            // samples actually available
            let count = self.blip.read_samples(&mut temp, false);
            self.wave_write(&temp[..count]);
        }
    }

    /// write the samples to the WAV file
    fn wave_write(&mut self, samples: &[i16]) {
        for s in samples.iter() {
            self.wav.write_sample(*s).expect("Failed to write sample");
        }
    }

    fn run_chan(&mut self, chan_idx: usize, end_time: u64) {
        let mut chan = &mut self.chans[chan_idx];
        match chan.chan_type {
            // Runs square wave to end_time
            ChanType::Square => {
                while chan.time < end_time {
                    chan.phase = (chan.phase + 1) % 8;
                    let amp = if chan.phase < chan.regs[TIMBRE] {
                        0
                    } else {
                        chan.regs[VOLUME]
                    };
                    chan.update_amp(&mut self.blip, amp);
                    chan.time += chan.regs[PERIOD] as u64;
                }
            }
            // Runs triangle wave to end_time
            ChanType::Triangle => {
                while chan.time < end_time {
                    // phase only increments when volume is non-zero (volume is otherwise ignored)
                    if chan.regs[VOLUME] != 0 {
                        chan.phase = (chan.phase + 1) % 32;
                        let amp = if chan.phase < 16 {
                            chan.phase
                        } else {
                            31 - chan.phase
                        };
                        chan.update_amp(&mut self.blip, amp);
                    }
                    chan.time += chan.regs[PERIOD] as u64;
                }
            }
            // Runs noise to end_time
            ChanType::Noise => {
                if chan.phase == 0 {
                    chan.phase = 1;
                }

                while chan.time < end_time {
                    chan.phase = ((chan.phase & 1) * chan.regs[TIMBRE]) ^ (chan.phase >> 1);
                    chan.time += chan.regs[PERIOD] as u64;
                }
            }
        }
    }
}

/// Type of waveform generated by a channel
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum ChanType {
    Square,
    Triangle,
    Noise,
}

/// Represents a channel
struct Chan {
    /// the type of signal generated
    chan_type: ChanType,
    /// overall volume of channel
    gain: i32,
    /// period (clocks between deltas)
    regs: [i32; 3],
    /// clock time of next delta
    time: u64,
    /// position within waveform
    phase: i32,
    /// current amplitude in delta buffer
    amp: i32,
}

impl Chan {
    fn new(chan_type: ChanType, gain: i32) -> Self {
        Self {
            chan_type,
            gain,
            regs: [10, 0, 0],
            time: 0,
            phase: 0,
            amp: 0,
        }
    }

    /// Updated amplitude of waveform in delta buffer
    fn update_amp(&mut self, blip: &mut BlipBuf, new_amp: i32) {
        let delta = new_amp * self.gain - self.amp;
        self.amp += delta;
        blip.add_delta(self.time, delta);
    }
}

fn wave_writer() -> Result<WavWriter<BufWriter<File>>, Box<dyn Error>> {
    let w = WavWriter::create(
        "out.wav",
        WavSpec {
            channels: 1,
            sample_rate: 44100,
            bits_per_sample: 16,
            sample_format: SampleFormat::Int,
        },
    )?;

    Ok(w)
}
